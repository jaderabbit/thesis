%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Nature Inspired Algorithms for Prioritized Foraging}
\label{chap:third}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter presents three algorithms for prioritized foraging. These three algorithms are based based upon phenomenon observed in nature. The first model is a simple foraging algorithm, called na\"ive foraging, which will form the benchmark algorithm for the experiments. Two novel swarm robotics foraging algorithms inspired by the foraging behaviour of desert ants and honey bees are also presented. Each of these algorithms have differing capabilities when it comes to memory, communication, division of labour, and navigation. The benchmark algorithm is presented in Section~\ref{naiveforaging}. Section~\ref{desertantforaging} introduces the novel foraging algorithm based on desert ants. Section~\ref{honeybeeforaging} presents a novel foraging algorithm inspired by honey bees. The algorithms are summarized in Section~\ref{prioritized:summary}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Na\"ive Foraging Algorithm}
\label{naiveforaging}

 Na\"\i ve foraging consists of the following tasks: searching for an item, grabbing an item, returning home with the item and storing the item at the sink. The steps performed by the algorithm are illustrated in Figure~\ref{naiveforagingstatediagram}.  

\begin{enumerate}
	\item Robots perform a random walk until they find an item.
	\item On locating an item, the robot grips the item. If the item has been moved before the robot is able to pick it up, the robot will continue to explore; otherwise, the robot returns the item to the correct sink using a beacon-based homing algorithm.
\end{enumerate}

\begin{figure} [h]
	\centering
	\begin{tikzpicture}[node distance=8cm]
	\node (randomwalk) [process] {random walk};
	\node (offload) [process, below of=randomwalk, yshift=4cm] {off-load};
	\node (loaditem) [process, right of=randomwalk] {load item};
	\node (homing) [process, right of=offload] {homing};
	\draw [arrow] (randomwalk) -- node[anchor=south] {locates item} (loaditem);
	\draw [arrow] (loaditem) -- node[anchor=west] {successful load} (homing);
	\draw [arrow] (homing) -- node[anchor=north] {at sink} (offload);
	\draw [arrow] (offload) -- node[anchor=west] {successful offload} (randomwalk);

	\draw[arrow,postaction={decorate,decoration={text along path,reverse path,raise=1ex,text align=center,text={unsuccessful load}}}] (loaditem) to[bend right=45] (randomwalk);
	\end{tikzpicture}
	\caption{Nai\"ve Foraging State Diagram}
	\label{naiveforagingstatediagram}
\end{figure}

Na\"\i ve foraging includes only the most minimal set of foraging actions and is included as a baseline for comparison to evaluate how novel techniques, such as the desert-ant foraging or honey-bee foraging, compare to a standard model \cite{ostergaard2001emergent,hoff2010two}.

The following random walk is used: A robot chooses a random direction, $\sigma$, and a random distance $m\in(0,M)$ where $M$ is a chosen maximum path length. The robot walks in direction $\sigma$ for distance $m$. The robot then chooses new values for $\sigma$ and $m$. 


\section{Desert Ant Foraging}
\label{desertantforaging}


As discussed in Section~\ref{biological:ants}, due to the lack of pheromone, desert ant foraging behaviour is a very suitable model for robot foraging since no pheromone depositors or pheromone mimickry is required. Instead of pheromone, desert ants use path integration (PI) to memorize the location of an existing food source and later to return to the memorized source to find more food, which was also addressed in Section~\ref{biological:ants}. The notion of returning to a previously explored site is known as site fidelity \cite{switzer1993site}. The desert ant algorithm does not require communication between robots or the dispersal of beacons, and is thus simpler than other many swarm robotics foraging algorithms. The desert ant foraging robots can be in the following states:

\begin{enumerate}
	\item\textbf{Exploration State} -- A robot in the exploration state performs a random walk with PI. The random walk used was the same as discussed in Section~\ref{naiveforaging}. The purpose of the exploration state is to explore the environment to locate items. 
	\item\textbf{Loading State} -- On finding an item, the robot switches into the loading state. In the loading state, the robot loads the item and memorizes the current PI vector. The PI vector is memorized so that the robot can use the it to return to the sink and then later to return the site where the item was found. If loading the item fails (perhaps due to another robot loading the item), then the robot returns to the exploration state; else the robot moves into the homing state.
	\item\textbf{Homing State} -- In the homing state, the robot uses the PI vector to move to the sink. The use of the PI vector will enable the robot to follow the most direct route back to the sink.
	\item\textbf{Offloading State} -- When the robot arrives at the sink, the robot switches into the offloading state where the robot simply offloads the item into the sink. 
	\item\textbf{Locating State} -- Once the robot has offloaded the item, the robot switches to the locating state. In the locating state, the robot follows the memorized PI vector to the location of the previous item. The premise of returning to the site where the previous item was found is that more items may exist where the previous item was located in order to locate more items. If another item is found, the robot moves into the loading state; otherwise the robot returns to the exploration state in the search of new items. 
\end{enumerate}

All robots begin at random positions adjacent to the sink in the exploration state. The desert ant foraging states and transitions are illustrated in Figure~\ref{fig:desertantstate}.

\begin{figure} [h]
	\centering
	\begin{tikzpicture}[node distance=6cm]
	\node (explorationstate) [process] {explore};
	\node (loadstate) [process, right of=randomwalk] {loading};
	\node (homing) [process, below of=loadstate,yshift=2cm] {homing};
	\node (offload) [process, left of=homing] {offload};
	\node (locating) [process, left of=explorationstate] {locating};
	\draw [arrow] (explorationstate) -- node[anchor=south] {locates item} (loadstate);
	\draw [arrow] (loadstate) -- node[anchor=west] {successful load} (homing);
	\draw [arrow] (homing) -- node[anchor=south] {at sink} (offload);
	\draw [arrow] (offload) -- node[anchor=east] {offload complete} (locating);
	\draw [arrow] (locating) -- node[anchor=south] {item not found} (explorationstate);
	\draw[arrow,postaction={decorate,decoration={text along path,raise=1ex,text align=center,text={locates item}}}] (locating) to[bend left=45] (loadstate);
	\draw[arrow,postaction={decorate,decoration={text along path,reverse path, raise=1ex,text align=center,text={unsuccessful load}}}] (loadstate) to[bend left=45] (explorationstate);
	\end{tikzpicture}
	\caption{Desert Ant Foraging State Diagram}
	\label{fig:desertantstate}
\end{figure}

	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Honey Bee Foraging}
\label{honeybeeforaging}
%TODO Describe the 3 states referring back to where they were discussed in the previous section.

The honey bee prioritized foraging algorithm presented in this section is based on the foraging behaviour of honey bees as described in Section~\ref{honeybeeinnature}. The algorithm described requires robots to take on three roles, namely, scout robots, unemployed forager robots and employed forager robots. The roles of the robots and the transitions to and from those roles are described in this section. 

Figure~\ref{honeybeestate} provides a simplified diagram for the honey bee prioritized foraging algorithm showing the roles and the transitions between them. The dance and explore states of the scout robots are shown separately for clarity and the employed forager states are outlined separately in Figure~\ref{employedforagerstatediagram}.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[node distance=10cm]
	\node (wait) [process] {unemployed forager};
	\node (forage) [process, right of=wait] {employed forager};
	\node (dance) [process, below of=forage,yshift=5cm] {dance};
	\node (scout) [process, left of=dance] {explore};
	
	\draw [arrow,postaction={decorate,decoration={text along path,raise=1ex,text align=center,text={recruited}}}] (wait) to[bend left=20] (forage);
	
	\draw [arrow] (forage) -- node[anchor=north] {$t_{forage} \geq t_{forage_{max}}$} (wait);
	
	\draw [arrow] (forage) to[bend left=20] node[anchor=west] {$\mu \geq \Phi$} (dance);
	\draw[arrow] (dance) to[bend left=20] node[anchor=east] {$r \geq \rho$} (forage);
	\draw [arrow] (dance) -- node[anchor=south] {$r < \rho$} (scout);
	\draw [arrow] (scout) -- node[anchor=east] {$t_{wait} > t_{wait_{max}}$} (wait);
	\draw [arrow,postaction={decorate,decoration={text along path,raise=1ex,text align=center,text={locates new site}}}] (scout) to[bend left=20] (dance);
	\draw [arrow] (forage) to[loop] node[anchor=south] {$\mu < \Phi$} (forage);
	\draw [arrow] (wait) to[loop] node[anchor=south] {$t_{forage} < t_{forage_{max}}$} (wait);
	\node[process, fit=(scout)(dance), inner sep=1.5cm, label={270:scout}] (all) {};
	\end{tikzpicture}
	\caption{Honey Bee Foraging State Diagram}
	\label{honeybeestate}
\end{figure}

\subsection{Scout Robots}
Scout robots mimic the scouting behaviour of the scout honeys bees as discussed in Section~\ref{honeybeeinnature}. The purpose of the scout robot is to locate sites of items and if the discovered site is of a high enough quality, then the scout will broadcast the location of the site to the unemployed forager robots at the sink. In more detail, each scout robot begins in the explore state. In the explore state, a scout robot performs a random walk. The random walk performed is the same random walk discussed in Section~\ref{naiveforaging}. Upon finding an item $\vartheta$ at site $\xi$, the robot loads the item and then performs an evaluation of the quality of the site $\xi$. 

The quality, $\mu_t$, of site $\xi$, for a robot scouting items of type $t$ is calculated as the estimated density of items of type $t$ in the local vicinity of the found item. The robot has distance sensor values $k_i\in[0,1]$ for $ i = 1...n$ where $n$ is the number of distance sensors. A distance sensor read;
ing of 0 means that nothing is detected in the sensor's range and a distance sensor reading of 1 indicates that the robot is touching an item. The sensor value $k_i$, for item type $t$, denoted $k_{i_t}$, is calculated as 
\begin{equation}
\label{densitytype}
k_{i_t}=
    \begin{cases}
      k_i & \text{if item $i$ is type $t$} \\
      0 & \text{otherwise}
    \end{cases}
\end{equation}

The site quality of type $t$, $\mu_t$, is calculated using
\begin{equation}
\label{density}
\mu_t = \frac{1}{n}\sum\limits_{i=1}^n k_{i_t}
\end{equation}
 
Before returning to the sink, the scout memorizes the PI vector $v$. Using PI vector $v$, the scout returns the item $u$ to the sink. When the scout robot has returned to the sink and successfully offloaded the item, the scout robot switches into the dance state.

In the dance state, the scout robot will decide whether to communicate the location, $v$, and quality $\mu$, of the previous site $\xi$, to the unemployed workers at the sink. The communication is akin to the waggle dance performed by honey bees in nature, as discussed in Section~\ref{honeybeeinnature}. A scout robot's ``dance" takes the form of a localized broadcast communication between the scout and the unemployed forager robots at sink $S$.

The scout robot will examine the site quality, $\mu$, to decide whether to communicate the details of site $\xi$. If the estimated quality of the site, $\mu$, is less than the dance threshold, $\phi$, the scout robot does not communicate the site details and instead returns to foraging state. If $\mu$, is greater or equal to $\phi$, the scout robot will communicate the site quality and location for the unemployed foragers. The scout robot broadcasts for $t_{dance}$ time steps.

After the scout robot has completed broadcasting site details to the unemployed foragers, the scout robot must decide to either stay a scout robot and switch back to the explore state or become an employed forager robot and begin foraging the previous site. The scout robot generates a random number, $r\in(0,1)$. If $r$ is less than a division of labour control parameter, $\rho\in(0,1)$, then the scout robot remains a scout and begins to explore t he environment. If $r$ is greater than or equal to $\rho$ then the scout becomes an employed forager and begins to relocate the site it just finished broadcasting.

\subsection{Forager Robots}

There are two types of forager robots: The unemployed foragers and employed foragers. The unemployed forager robots and forager robots are discussed in this section together.

Th unemployed forager robots take on the role of unemployed foragers or workers from foraging honey bees discussed in Section~\ref{honeybeeinnature}. Unemployed forager robots remain at the sink and await recruitment behaviour from a scout robot. When a scout robot dances at the sink after locating an item $v$, each unemployed forager chooses, with a probability $\alpha$, whether to listen to the details broadcasted by the scout robot of location $v$. The acceptance of the details broadcasted by the scout is known as recruitment. If an unemployed forager robot is recruited by the scout robot, the unemployed forager robot becomes an employed forager robot.

The employed forager robots are modelled after the employed forager bees as discussed in Section~\ref{honeybeeinnature}. The purpose of the employed forager robot is to forage the sites broadcasted by scout robots. After an unemployed forager robot has become an employed forager robot after recruitment by a scout robot, the employed forager begins in the locate state. In the locate state, the employed forager robot uses the PI vector calculated and communicated by the scout robot to the employed forager, to relocate the site of the scout robot. Once the site has been relocated, the employed forager robot switches into the load state and picks up the item. After successfully loading them item, the robot uses the PI vector to relocate the sink and then off-loads the item. Once the employed forager drops off the item at the sink, the employed forager robot switches to the locate step and then repeats the steps of foraging the site that the robot was recruited to forage. 

An employed forager robot becomes an unemployed forager robot, when the foraging site that the scout broadcasted has been depleted. A foraging site has been depleted when a employed forager robot can't detect an item in the area surrounding the broadcasted location $v$ at which point the employed forager returns to the sink without and item and becomes an unemployed forager robot in the wait state. 

The states and transitions of the employed forager are shown in more detail in Figure~\ref{employedforagerstatediagram}, since they could not fit into Figure~\ref{honeybeestate}. 

\begin{figure} [h]
	\centering
	\begin{tikzpicture}[node distance=6cm]
	\node (locate) [process] {locate};
	\node[initial, left of=locate,xshift=3cm] (start) {start};
	\node (load) [process, right of=locate] {load};
	\node (homing) [process, below of=load,yshift=2cm] {homing};
	\node (offload) [process, left of=homing] {off-load};
	\draw [arrow] (locate) -- node[anchor=south] {locates site} (load);
	\node[initial, right of=load,xshift=-1.5cm] (end) {end};
	\draw [arrow] (load) -- node[anchor=west] {successful load} (homing);
	\draw [arrow] (homing) -- node[anchor=south] {arrive at sink} (offload);
	\draw [arrow] (offload) -- node[anchor=east] {offload complete} (locate);
	\draw [arrow] (start) -- node[anchor=east] {} (locate);
	\draw [arrow] (load) -- node[anchor=north] {load failed} (end);
	\end{tikzpicture}
	\caption{State Diagram of an Employed Forager Robot}
	\label{employedforagerstatediagram}
\end{figure}


The unemployed forager robot role allows the number of active robots in the environment to be regulated so that there are not too many robots attempting to forage or explore at once. An environment with too many employed foragers would result in more collisions between robots, which would mean the employed foragers take longer to forage items. Also, if there too many employed foragers in a environment which is sparse in items, then the employed foragers are not only causing collisions but they're also wasting energy by exploring areas unnecessarily.

Unemployed forager robots become scout robots, if no scout robot broadcasts are detected for $t_{wait_{max}}$ time steps. The control parameter $t_{wait_{max}}$ is the maximum waiting time an unemployed forager can spend in the waiting state, before switching to a scout robot and $t_{wait}$ is the time spent by a robot in the waiting state. Decreasing $t_{max}$ results in more scout robots exploring the environment and less unemployed foragers that a scout robot, who may have found quality sites, can recruit. Increasing $t_{wait_{max}}$ results in a greater amount of unemployed forager robots waiting to be recruited. The greater quantity of unemployed foragers can form a large work force for a recruiting scout, however too many unemployed foragers results in a smaller workforce in the foraging environment.

\subsection{Initial States}

A portion of the robots are initialized as scout robots in the explore state and the rest as unemployed forager robots. All robots are initialized adjacent to the sink. The percentage of robots initialized as scout robots is $X$. One should note that robots can't be initialized as employed forager robots since unemployed forager require a scout robot to recruit them to learn the location of the sites and become employed foragers and at initialization, the scouts do not yet have site location details available.

\subsection{Division of Labour}
The honey bee algorithm has two levels of division of labour. The first level is the division of labour between the scout, unemployed forager and unemployed forager as described in this section.

However, another level of division of labour is addressed to deal with division of labour between foraging items with different priorities. Item-type division of labour is defined in this search as the division of labour between foraging prioritized item types and non-prioritized item types.

In nature, in times of drought, bees prioritize water over nectar or pollen. Honey bees would be sent out to forage for water but may encounter pollen while searching for water. If the foraging honey bee happens to encounter pollen, they will forage the pollen but will not communicate the discovery of the pollen site to the unemployed foragers  \cite{seeley2009wisdom}. Using the bee's prioritization of resources as inspiration, the following rules for division of labour are defined:

\begin{enumerate}
\item An employed forager or scout robot that is set to search for or forage the prioritized type $p$ will only forage a non-prioritized $n$ type only if a prioritized item can not be located for the maximum time period, $f_{max}$.
\item A robot foraging the non-prioritized item type will forage the non-prioritized item type until the robot fails to relocate a previously located non-prioritized item type site or until the robot locates a prioritized item. In either case, the robot will switch to foraging the prioritized item type.
\item A robot foraging a non-prioritized item will not communicate the location of the non-prioritized item site by dancing. 
\end{enumerate}

For the purpose of this study, each robot of each algorithm is assigned an initial item type to forage. The robots of desert ant foraging algorithm and the na\"ive algorithm do not have item-type level division of labour and thus will continue to forage the same item-type that they were assigned throughout the experiment. The robots in the honey bee algorithm may switch what item-types they forage during the experiment, due to the item-type division of labour. 

\subsection{Pseudo code}
To more succinctly and specifically define the honey bee prioritized foraging algorithm, the algorithm pseudo code for each behaviour has been provided: Exploration state of a scout robot is outlined in Algorithm~\ref{algorithm:explore}. Algorithm~\ref{algorithm:scout:homing} explains the homing behaviour of a scout robot while the recruitment state of a scout robot is defined in Algorithm~\ref{algorithm:recruit}. 

The presented algorithms differ in three main properties as summarized in Table \ref{properties}.

Suppose robot has item priority $t={P,N}$, where $P$ is the state where the the robot is set to forage prioritized items and $N$ is the state when the robot is set to forage non-prioritized items. The current location is denoted by $l$. The current timestep is denoted $i$. $state$ is the current state of the robot. $pi_vector$ is the path integration vector

% Scout algorithms
\begin{algorithm}
\caption{Explore State of Scout Robot}
\label{algorithm:explore}
\begin{algorithmic}[1]
\Function{explore}{$state, l, v, t, i$}
%move random direction from location l
\State \text{perform a random walk step from location \textit{l}}
\State \text{update path integration vector \={v}}
\If {\text{item $\vartheta$ of priority $t$ is detected in vicinity}}
 	\State \text{calculate quality $\mu_t$ of site $\xi$ }
	\State {$\omega \gets v$}
	\State load item $\vartheta$
\ElsIf {$i > f_{max}$ and $i \leq t_{max}$}
	\State $t \gets N$
\ElsIf {$i > t_{max}$}
	\State $state \gets homing$
\EndIf
\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Homing State of Scout Robot}
\label{algorithm:scout:homing}
\begin{algorithmic}[1]
\Function{scout homing}{$role, state, l, v, t, i, \omega$}
\If {\text{robot is at sink $S_t$ and robot is loaded}}
	\State \text{robot offloads item $\vartheta$}
	\If {\text{$\mu_t > \phi$}}
		\State \text{$state \gets dance$}
	\Else 
		\State \text{$role \gets \text{employed forager}$}
		\State \text{$state \gets locate$}
	\EndIf
\Else
	\State{\text{calculate direction $d$ to sink $S_t$ from current location $l$}}
	\If{\text{robot can move in direction $d$}}
		\State \text{robot moves in direction $d$}
	\EndIf
\EndIf
\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Dance State of Scout Robot}
\label{algorithm:recruit}
\begin{algorithmic}[1]
\Function{dance}{$role, state, l, v, t, i, \omega, \mu_t$}
\If {$i < t_{max}$}
	\State \text{broadcast $\omega$ and $\mu_t$ to robots at the sink} 
\Else 
	\If {$random(0,1) < \rho$} 
		\State{$role \gets \text{employed forager}$}
		\State{$state \gets locate$}
	\Else
		\State{$state \gets explore$}
	\EndIf
\EndIf
\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}

% Employed Forager
\begin{algorithm}
\caption{Locate State of Employed Forager}
\label{algorithm:employedforager:locating}
\begin{algorithmic}[1]
\Function{forage}{$role, state, l, v, t, i, \omega, \mu_t$}
	\State \text{direction $d = \omega - l$ }
	\State \text{robot moves in direction $d$}
	\If {\text{$\omega - l == 0$ OR robot can see item of type $t$}}
		\State $state \gets load$
	\EndIf
	\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Load State of Employed Forager}
\label{algorithm:loading}
\begin{algorithmic}[1]
\Function{loading}{$role, state, l, v, t, i, \omega, \mu_t$}
\If {\text{item $\vartheta$ of priority $t$ is detected in vicinity}}
	\State \Call{load}{$\vartheta$}
	\State{$state \gets homing$}
\Else
	\State{$state \gets local\_search$}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Local Search State of Employed Forager}
\label{algorithm:employedforager:localclustersearch}
\begin{algorithmic}[1]
\Function{local\_search}{$role, state, l, v, t, t_{ls}, i, \omega, \mu_t$}
\If {\text{$t_{ls} < t_{ls_{max}}$}}
		\If {\text{item $\vartheta$ of priority $t$ is nearby and can be loaded}}
			\State \Call{load}{$\vartheta$}
			\State{$state \gets homing$}	
		\ElsIf {\text{item $\vartheta$ of priority $t$ can be seen but is not close enough}}
			\State \text{select direction $d$ to move towards item $\vartheta$}
			\State \text{robot moves in direction $d$}
		\Else
			\State \text{select a random direction $d$}
			\State \text{robot moves in direction $d$}	
		\EndIf
\Else
	\State{$state \gets homing$}
\EndIf
\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Homing State of Employed Forager Robot}
\label{algorithm:forager:homing}
\begin{algorithmic}[1]
\Function{employed forager homing}{$state, l, v, t, i, \omega$}
\If {\text{robot is at sink $S_t$}}
	\If {\text{robot is loaded}}	
		\State \text{robot offloads item $\vartheta$}
		\State $state \gets locate$
	\ElsIf {\text{robot is not loaded}}
		\State{\text{$role \gets \text{unemployed forager}$}}
		\State {\text{$state \gets wait$}}
	\EndIf
\Else
	\State{\text{calculate direction $d$ to sink $S_t$ from current location $l$}}
	\If{\text{robot can move in direction $d$}}
		\State{\text{robot moves in direction $d$}}
	\EndIf
\EndIf

\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Wait State of Unemployed Forager}
\label{algorithm:unemployedforager:locating}
\begin{algorithmic}[1]
\Function{wait}{$state, l, v, t, i, \omega, \mu_t$}
\If {$t_{wait} > t_{wait_{max}}$}
	\State{$state \gets explore$}
\ElsIf {\text{scout robot is broadcasting at sink}}
	\State \text{receive site location $\omega$ and site quality $\mu_t$}
	\State $role \gets \text{employed forager}$
	\State $state \gets locate$
\EndIf
\State $i =i + 1$
\EndFunction
\end{algorithmic}
\end{algorithm}


\section{Summary}
\label{prioritized:summary}

This chapter introduced two novel algorithms for foraging robot swarms: a desert ant inspired foraging algorithm, as well as a honey bee inspired foraging algorithm. A benchmark algorithm called na\"ive foraging, is also presented. The desert ant algorithm uses path integration to memorize the location of an item site and return to the site to forage more items. The honey bee algorithm is substantially more complex with three roles for robots: scout, unemployed forager and employed forager. The scout robots in the honey bee algorithm uses path integration to memorize the location of a site as well as evaluate the quality of the site. The location and quality of a site is communicated by the scout to unemployed foragers through direct communication. The unemployed forager are recruited and become employed foragers. The honey bee algorithm also exhibits division of labour between prioritized and non-prioritized items. An overview of the properties of the algorithms are given in Table~\ref{properties}.

\begin{table} [h]
    \caption{Properties of the foraging algorithms used in this study}
    \label{properties}
	\centering
    \begin{tabular}{|l|c c c|} \hline
    Property           & Na\"ive  & Desert Ant  & Honey Bee  \\ \hline
    Memory             & \xmark  & \cmark     & \cmark    \\
    Communication      & \xmark  & \xmark     & \cmark    \\
    Division of Labour & \xmark  & \xmark     & \cmark    \\ \hline
    \end{tabular}

\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%