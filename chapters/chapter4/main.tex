%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Experimental Setup}
\label{chap:experiment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter describes the experimental setup for the simulations that were performed for the purposes of this study. Section~\ref{chap:robots} describes the robots used in the study, while the simulation environment is described in Section~\ref{simulator}. The environments used in the experiment are discussed in Section~\ref{experimentenvironments}, and Section~\ref{parameters} defines the parameters for the robot swarm. Section~\ref{thri:third:performancemeasures} proposes performance measures to be used to evaluate the performance of the algorithms on the prioritized foraging problem. The chapter is summarized in Section~\ref{third:summary}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Robots}
\label{chap:robots}

Foraging robots occur in all shapes, sizes and capabilities. Some robots have powerful GPS capabilities and advanced long distance sensors, while others are much simpler. This chapter defines the capabilities of the simulated robots to be used in this study. The robots are described in Section~\ref{robotdescription}, while Section~\ref{navigationandobstacleavoidance} outlines the navigational capabilities of the robots. 

\subsection{Robot Description}
\label{robotdescription}

The artificial robots modelled in this study are based on e-puck robots \cite{mondada2009puck}, which have been modified with grippers. A robot is equipped with a 360 degree camera to identify objects around the robot, as well as eight local distance sensors equally spaced around the circular perimeter of the robot. Both camera and distance sensors have a depth of view of five times the robot's size. Robots use local communication which can occur in a radius of five times the robot's size. The sensor and communication range is sufficiently localized with respect to the size of the environment. A robot can forage a single item at a time. The robots do not have a global positioning system (GPS) capability to locate items to position themselves in the environment. A robot can not see occluded items. As a result, robots have to explore the environment to find the prioritized items.

\subsection{Navigation and Obstacle Avoidance}
\label{navigationandobstacleavoidance}

The environments used in the simulation have a variety of complexities: Some environments are very sparse, while others have large zones of non-prioritized items that must be navigated around or foraged to clear a route to the prioritized items. Due to the environmental complexity, an advanced navigation and obstacle avoidance technique is required.

The robots in the experiments for this thesis use a navigation and obstacle avoidance technique inspired by a congestion avoidance technique developed for communication congestion avoidance in wireless sensor networks \cite{antoniou2012congestion}. Antoniou \textit{et al} use inspiration from the flocking behaviour of birds in order to efficiently route messages around congested areas in wireless sensor networks. In flocking behaviour of birds, birds are attracted by a global magnetic attractor to the birds' final destination, while a local attractor pulls flocking birds away from areas of congestion. In the congestion avoidance algorithm, the final destination of the message being sent on the wireless sensor network is a combination of the global attractor and the local attractor.

The described congestion avoidance technique has been adapted to form a simple but effective navigation and obstacle avoidance technique. Robots are pulled to a global attractor, which is the intended destination, while a local attractor directs robots away from local obstacles while maintaining a course to the destination.

Figure \ref{fig:obstacleavoidance} illustrates the navigation and obstacle avoidance method used by the robots. The navigation and obstacle avoidance algorithm achieves the effect of the global attractor by setting the robots' field of view towards the direction of the desired destination. The destination is determined by a homing beacon or by the robot's path integration vector. The direction at the centre of the field of view is the direction to the destination. 

\begin{figure}
	\centering
	\includegraphics[width=0.75\textwidth]{chapters/chapter5/figures/ObstacleAvoidance.pdf}
	\caption{Navigation and obstacle avoidance, where $\eta$ is depth of view, $f$ is the field of view, $R$ is the robot, $dir$ is the direction of the destination and $L$ is a possible value of local attractor}
	\label{fig:obstacleavoidance}
\end{figure}

The effect of the local attractor is modelled by evaluating each direction in the field of view to select the most desirable direction. Desirability, $d$, of a direction, $q$, is a metric quantifying the how well a direction achieves a balance between clarity of the path and directness of the direction to the destination. The clarity, $\kappa_a$, in a direction $i$, is a normalized reading from the proximity sensor or camera such that $\kappa_q\in[0,1]$. Clarity indicates the distance to the next nearest obstacle. If no obstacles exist in the depth of view $\eta$, then  $\kappa_q=0$. If there exists an obstacle immediately next to the robot, then $\kappa_q=1$. The directness of a direction $q$, $\iota_q\in[0,1]$ is calculated as the angular deviation from the direction of the destination, where $\iota_q=0$ occurs when the direction $i$ is the same as direction to the destination, $dir$, and a $\iota_q=1$ occurs when the direction is at the edge of the field of view, $f$. Desirability $d_q$ of direction $q$ is defined as.

\begin{equation}
	d_i= \lambda \kappa_q + (1 - \lambda)\iota_q \\
	\label{eq:1}
\end{equation} where $\lambda$ determines whether clarity, $\kappa_q$, or directness, $\iota_q$, of direction $q$, has a greater effect on desirability. The described navigation and obstacle avoidance technique is used with all algorithms in the experiment and for all algorithms, $\lambda$ is set to 0.5.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulator}
\label{simulator}
A spatially discrete 2-dimensional grid world simulator has been developed and used in this thesis in order to accelerate computation. Discrete 2-dimensional grid world simulators are also used in \cite{sugawara2002swarming, hecker2015beyond}. In real robot experiments, algorithm performance is sensitive to the amount of time taken to load items and manoeuvre the robots \cite{ostergaard2001emergent}. The 2-dimensional grid world simulator allows for movement and loading time to be standardized across all algorithms for effective comparison.

The simulated robots function as follows:
\begin{itemize}
	\item Each robot fits into one grid block and each item takes up one grid block. 
	\item Only a single object can occupy a grid block at a time.  An object is either a robot or an item. Since only one object can occupy a grid block at a time, collisions and congestion can occur.
	\item Each robot can move to an adjacent cell in any direction.
	\item Robots can load, transport and offload a single item at a time.
	\item If a robot cannot pick up an item, the item is an obstacle that a robot may have to navigate around in order to reach its destination.
\end{itemize}

The prioritized and non-prioritized sinks were placed next to each other, on a single side of the environment. The sinks were marked by beacons that all robots can detect and navigate towards. The reason why the sinks were not placed in the centre of the environment, as is commonly found in swarm robotics research \cite{labella2006division}, is because the prioritized foraging problem is inspired from using a swarm of robots to rescue trapped miners in mining tunnels, discussed in Section~\ref{sec:second:prioritizedforaging}. A mining tunnel has a single entrance where the gold and waste must be moved to, in order to be transported to the surface \cite{brune2010extracting}. Since there is only a single entrance at the beginning of a tunnel, the sinks need to occur at the beginning of the tunnel so that items can be easily exported.

\section{Environments}
\label{experimentenvironments}

The experiments were run on different environments each with different item distributions, environment sizes, item densities and different ratios of prioritized to non--prioritized items. 

The sizes, $S$, of the environment grid were varied, where $S\in \left\{ 50, 100, 200, 300, 500\right\}$, where $S$ was the width and length of the grid.

Different values for the density, $p$, of the items on the grid were chosen, such that if $p=0.9$, then 90\% of the grid cells are occupied by items, with $p\in \{ 0.05,\allowbreak 0.2,\allowbreak 0.5,\allowbreak 0.7,\allowbreak 0.9\}$. Environments with a higher item density are more complex to forage, since there exists a higher probability that an item of the type that the robot is not foraging will block the path to items of the type that the robot is foraging.

The ratio, $r$, of prioritized to non-prioritized items was varied, with $r\in \{0,\allowbreak 0.2,\allowbreak 0.25,\allowbreak 0.33,\allowbreak 0.5,\allowbreak 0.67,\allowbreak 0.75,\allowbreak 0.8, 1\}$. For $r=0$, there are no prioritized items on the grid, and when $r=1$, there exist only prioritized items on the grid. Environments with a small $r$ value have an abundance of non-prioritized items which increases the likelihood of non-prioritized items blocking access to prioritized items. 

Different distributions of items over the environment were chosen to examine different characteristics of the algorithms. The item distributions are illustrated in Figure~\ref{fig:environments}, where each lighter shaded square is a prioritized item and a non-prioritized item is shown by a darker shaded square. Four different classes of environments were generated as follows:

\begin{figure} [h]
        \centering
        \begin{subfigure}[b]{0.21\textwidth}
                \includegraphics[width=\textwidth]{chapters/chapter4/figures/uniformenv.pdf}
                \caption{Uniform}
                \label{fig:uniformenv}
        \end{subfigure}%
		\begin{subfigure}[b]{0.2\textwidth}
                        \includegraphics[width=\textwidth]{chapters/chapter4/figures/gaussianenv}
                        \caption{Gaussian}
                        \label{fig:gaussianenv}
       \end{subfigure}
        \begin{subfigure}[b]{0.205\textwidth}
                \includegraphics[width=\textwidth]{chapters/chapter4/figures/clusterenv.pdf}
                \caption{Clustered}
                \label{fig:clusterenv}
        \end{subfigure}
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{chapters/chapter4/figures/veinenv.pdf}
                \caption{Vein}
                \label{fig:veinenv}
        \end{subfigure}  

        \caption{Environment Classes}\label{fig:environments}
\end{figure}

\begin{algorithm}

\caption{Uniform Distributed Environments}
\label{algorithm:uniform}
\begin{algorithmic}[1]
\Function{uniform}{$numberItems, r, S$}
	\State \text{nonPrioritizedItemsLeft = floor((1-$r$)*numberItems)}
	\State \text{prioritizedItemsLeft = floor( $r$*numberItems)}
	\While{\text{$prioritizedItemsLeft > 0$}}
		\State \text{x $\gets$ uniform(0, S)}
		\State \text{y $\gets$ uniform(0, S)}
		\If{\text{gridCell (x,y) is empty}}
			\State \text{Place prioritized item at (x,y)}
			\State \text{Decrement $prioritizedItemsLeft$}
		\EndIf
	\EndWhile

	\While{\text{$nonPrioritizedItemsLeft > 0$}}
		\State \text{x $\gets$ uniform(0, S)}
		\State \text{y $\gets$ uniform(0, S)}
		\If{\text{gridCell (x,y) is empty}}
			\State \text{Place prioritized item at (x,y)}
			\State \text{Decrement $nonPrioritizedItemsLeft$}
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{enumerate}

\item The position of each item in a uniformly distributed environment is selected from a uniform distribution (refer to Figure~\ref{fig:uniformenv}). The uniformly distributed environment has uniform concentrations of prioritized and non-prioritized items across the environment and thus is used as a control environment. Pseudo-code for generation of uniform environment is provided in Algorithm~\ref{algorithm:uniform}.

\item For the Gaussian environments, the positions of the prioritized items are sampled from a Gaussian distribution. The mean of the Gaussian disitribution is the centre of the grid. The deviation of the Gaussian distribution was selected as $deviation = S*E_p/2$, to ensure that generation took a reasonable amount of time (that the same positions are not reselected regularly), but that the non-prioritized items were densely concentrated  (refer to Figure~\ref{fig:gaussianenv}). Pseudo-code for generation of Gaussian environments is provided in Algorithm~\ref{algorithm:gaussian}. The positions of the non-prioritized items are selected from a uniform distribution, after placing the prioritized items. 

In Gaussian distributed environments, prioritized items  occur in high concentration towards the center of the environment. More non-prioritized items occur on the outskirts of the environment, surrounding the prioritized items in the centre.

The Gaussian environments were used to examine whether each algorithm will enable the robot swarm to forage or navigate past the non-prioritized items to reach the high concentration of prioritized items in the environment's centre. 


\item Environments with a vein distribution resemble the patterns observed in naturally occurring gold reefs \cite{frimmel2002recent} (refer to Figure~\ref{fig:veinenv}). In a gold reef, molten gold fills planar fractures between rock resulting in a vein of gold. Inspired by gold reefs, vein distributed environments have a long thin vein of prioritized items running from one side of the environment to another. The vein of prioritized items was surrounded by non-prioritized items. 

The vein environments aimed to test whether a swarm of robots could forage the continuous length of the vein of prioritized items, before foraging non-prioritized items. A swarm that is able to detect the location of the vein and return to the vein's location after foraging an item should forage more prioritized items initially, than an algorithm that cannot detect and remember the location of the vein.  Pseudo-code for generation of vein environments is provided in Algorithm~\ref{algorithm:vein}.


\item Environments with a clustered item distribution have a random number of clusters of items of the same type (refer to Figure~\ref{fig:clusterenv}). After clusters have been generated, each cluster is labelled randomly (with a Bernoulli disitribution with probability equal to the item ratio required for that environment, $r$), as either a cluster of prioritized items or a cluster of non-prioritized items, 

The goal of performing experiments in a clustered environment was to test an algorithm's ability to exploit areas which are rich in prioritized items. Clustered environments are also used to test whether an algorithm can either navigate around or forage non-prioritized items. A clustered environment can also test an algorithm's ability to remember locations of areas which have a high density of prioritized items, in order to aid more efficient access to prioritized items.  Pseudo-code for generation of clustered environments is provided in Algorithm~\ref{algorithm:clustered} and Algorithm~\ref{algorithm:clustered2}.


\end{enumerate} 

To summarize, the challenges introduced by the more complex distributions (the Gaussian, clustered and vein environment) aim to test a swarm's ability to:

\begin{itemize}
\item navigate past obstacles efficiently, or alternatively, to forage obstacles efficiently and to
\item return to areas rich in prioritized items to forage these areas.
\end{itemize}



\begin{algorithm}
\caption{Gaussian Distributed Environments}
\label{algorithm:gaussian}
\begin{algorithmic}[1]
\Function{gaussian}{$numberItems, r, S$}
	\State \text{Calculate environment centre point $(x_c, y_c)$}
	\State \text{prioritizedItemsLeft = floor($r$*numberItems)}
	\State \text{nonPrioritizedItemsLeft = floor((1-$r$)*numberItems)}
	\State \text{deviation = S*$r$/2}
	\While{\text{$prioritizedItemsLeft > 0$}}
		\State \text{$x \gets floor(gaussian(x_c, deviation))$}
		\State \text{$y \gets floor(gaussian(y_c, deviation))$}
		\If{\text{gridCell (x,y) is empty and is valid}}
			\State \text{Place prioritized item at (x,y)}
			\State \text{Decrement $prioritizedItemsLeft$}
		\EndIf
	\EndWhile

	\While{\text{$nonPrioritizedItemsLeft > 0$}}
		\State \text{x $\gets$ uniform(0, S)}
		\State \text{y $\gets$ uniform(0, S)}
		\If{\text{gridCell (x,y) is empty}}
			\State \text{Place non prioritized item at (x,y)}
			\State \text{Decrement $nonPrioritizedItemsLeft$}
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Vein Distributed Environments}
\label{algorithm:vein}
\begin{algorithmic}[1]
\Function{vein}{$numberItems, r, S$}
	\State \text{Select two random sides from the grid}
	\State \text{Select a random points on each sides, $(x_0,y_0)$ and $(x_1,y_1)$}
	\State \text{Calculate gradient of vein, $m = (y_0 - y_1)/(x_0 - x_1)$}
	\State \text{Calculate $c$ of equation for line vein, $c = (y_0 - m*x_0)$
}

	\State \text{prioritizedItemsLeft = floor($r$*numberItems)}
	\State \text{nonPrioritizedItemsLeft = floor((1-$r$)*numberItems)}

	\While{\text{$prioritizedItemsLeft > 0$}}
		\State \text{$x \gets uniform(min(x_0,x_1), max(x_0, x_1))$}
		\State \text{$y \gets m*x + c$}
		\If{\text{gridCell (x,y) is valid and gridCell (x,y) is empty}}
			\State \text{Place prioritized item at (x,y)}
			\State \text{Decrement $prioritizedItemsLeft$}
		\EndIf
	\EndWhile

	\While{\text{$nonPrioritizedItemsLeft > 0$}}
		\State \text{x $\gets$ uniform(0, S)}
		\State \text{y $\gets$ uniform(0, S)}
		\If{\text{gridCell (x,y) is empty}}
			\State \text{Place nonprioritized item at (x,y)}
			\State \text{Decrement $nonPrioritizedItemsLeft$}
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}

%TODO
\caption{Clustered Distributed Environments (Part 1)}
\label{algorithm:clustered}
\begin{algorithmic}[1]
\Function{clustered}{$numitems, r, S$}
  \State \text{Generate number of clusters, $total = uniform(3,15)$}
  \State \text{Calculate number of prioritized clusters, $clusters_p = floor(r*total)$}    
  \State \text{Calculate number of non-prioritized clusters, $clusters_{np} = floor((1-r)*total)$}
  
  \State \text{Calculate number of prioritized items, $total_p = floor(r*numitems)$}
  
  \State \text{Calculate number of non-prioritized items, $total_{np} = floor((1-r)*numitems)$}
  
  \State \text{$ave_p = total_p/clusters_{p}$}
  \State \text{$ave_np = total_{np}/clusters_{np}$}
  \State \text{$clusterstogenerate_p = clusters_p$}
  \State \text{$clusterstogenerate_{np} = clusters_{np}$}

  \While{\text{$clusterstogenerate_p > 0$}}
    \State \text{sample centroid for cluster $C$ (x,y) uniformly from grid}
    \State \text{$num_p = uniform(ave_p/2$, $2*ave_p$)}
    \State \text{Calculus radius, $r$, of cluster $C$ as $r = \sqrt{num_p/\pi}$}
    \If{\text{cluster $C$ does not collide with existing clusters}}
      \State \text{Save centroid and radius of cluster $C$ to list}
      \State \text{Decrement $clusterstogenerate_p$}
      \State \text{$itemstogenerate_p = num_p$}
          
      \While {$itemstogenerate_p > 0$}
        \State \text{$x_p = gaussian(x, r)$}
        \State \text{$y_p = gaussian(y, r)$}
        \If{\text{position $(x_{p},y_{p})$ is valid}}
          \State \text{Place prioritized item at $(x_p,y_p)$}
          \State \text{Decrement $itemstogenerate_{np}$}	
        \EndIf
      \EndWhile
    \EndIf
  \EndWhile
  \algstore{clusteredalg}
\end{algorithmic}
\end{algorithm}
  
\begin{algorithm}

%TODO
\caption{Clustered Distributed Environments (Part 2)}
\label{algorithm:clustered2}
\begin{algorithmic}[1]
  \algrestore{clusteredalg}
  \While{\text{$clusterstogenerate_{np} > 0$}}
	  \State \text{sample centroid for cluster $C$ (x,y) uniformly from grid}
	  \State \text{$num_{np}=uniform(ave_{np}/2,2ave_{np})$}
	  \State \text{Calculus radius, $r$, of cluster $C$ as $r = \sqrt{num_{np}/\pi}$}
	  \If{\text{cluster $C$ does not collide with existing clusters}}
	
		  \State \text{Save centroid and radius of cluster $C$ to list}
		  \State \text{Decrement $clusterstogenerate_{np}$}
		  \State \text{$itemstogenerate_{np} = num_{np}$}
				
		  \While {$itemstogenerate_{np} > 0$}
        	\State \text{$x_p = gaussian(x, deviation=r)$}
        	\State \text{$y_p = gaussian(y, deviation=r)$}
			\If{\text{position $(x_{np},y_{np})$ is valid}}
				  \State \text{Place non-prioritized item at $(x_{np},y_{np})$}
				  \State \text{Decrement $itemstogenerate_{np}$}	
			  \EndIf
		  \EndWhile
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\section{Swarm Parameters}
\label{swarmparameters}

For all algorithms, each robot swarm was initialized with 
a swarm specialization ratio, $\tau\in\left\{0, 0.2, 0.25, 0.333, 0.5, 0.667, 0.75, 0.8,1\right\}$. The swarm specialization ratio is the ratio of robots foraging prioritized items to non-prioritized items. When no robots are set to initially forage prioritized items, then $\tau=0$ and when all robots are set to initially forage prioritized items, then $\tau=1$.

The ability of an algorithm to adapt the value of $\tau$ appropriately for a given $r$ indicates the flexibility of the algorithm.


The swarm size, $c$, is defined as the number of grid cells occupied by a robot, as a percentage of the total number of grid cells, i.e S x S. Values of c\in{...} where evaluated


The swarm size, $c$, is defined as the number of cells occupied by a robot, as a percentage of the grid size $S$ (the length of the side of an environment), where values of $c\in\left\{0.1, 0.3, 0.5, 0.7, 1\right\}$ where evaluated. The swarm size is varied in order to test the scalability of the algorithm. The swarm size is also varied to test each algorithms' ability to adjust the number of actively foraging robots to the density of the items in the environment, $c$, as well as adjust the number of robots actively foraging an item type, $\tau$, to the item type density, $r$.

The honey bee algorithm specific parameters were selected based on \cite{seeley2009wisdom}, where
 $t_{wait}=200$ time steps, $f_{max}=100$ time steps, $\Phi=0.8$ and $\rho=0.1$. Testing the effect of each of the honey bee algorithm specific parameters was not in the scope of this thesis.

The initial position of each robot was randomly selected, adjacent to the sink. All robots began in the exploration state -- state that is shared by all algorithms. For each set, environmental and swarm configurations, each simulation was run for 10000 time steps. An experiment consists of 30 repeated samples, for a set of environment and swarm parameters.

\section{Performance Measures}
\label{thri:third:performancemeasures}

The performance of swarm robotics algorithms can be measured by examining the algorithm's ability to perform a task in terms of efficiency, scalability, flexibility, and robustness.

\subsection{Foraging Efficiency}
\label{setup:foragingefficiency}
The foraging efficiency, $E_P$, of a particular algorithm is defined as the total number of prioritized items collected by all robots in a fixed time period on a specific environment. This foraging efficiency metric is similar to the efficiency metric used by Hecker \textit{et al} \cite{hecker2015beyond}. The metrics used in experiments performed by Hecker \textit{et al} evaluate the performance of foraging algorithms and are thus appropriate for use in the experiments of this study. The metric only looks at the prioritized items for the prioritized foraging problem.

\subsection{Flexibility}
\label{setup:flexibility}
As stated in Section~\ref{flexibility}, to measure flexibility is to measure of how variations in environments and tasks affect the co-ordination mechanisms of swarm robotics algorithms. An algorithm that is highly flexible, is one that has been optimized for a specific distribution, but is equally efficient on a different distribution \cite{hecker2015beyond}.

The flexibility performance measures used in this study are based on the flexibility performance measures used in \cite{hecker2015beyond}, which have been adapted for the prioritized foraging problem, by only taking into account the prioritized item. The flexibility study addresses at two aspects: (i) Flexibility over the prioritized item ratios, $r_i$, and (ii) flexibility over environment distributions.

\subsubsection{Flexibility over prioritized item ratio}
\label{setup:flexibility:prioritizeditemratio}

This study evaluates flexibility by looking at how swarm efficiency is effected by different environment item ratio $r_i$, as described in Section~\ref{experimentenvironments} and swarm specialization ratio, $\tau_i$, as described in Section~\ref{swarmparameters}. The value for $\tau$, which results in the best average efficiency, $E_p$, for a specific $r_i$ is denoted as $\hat{\tau}_{r_i}$ and the average efficiency for a specific swarm specialization ratio, $\tau$ over specific environment item ratio, $r$ is denoted $E_p(\tau, r)$.

Flexibility over prioritized item ratio, $F_r$ is defined as:

\begin{equation}
	F_r = \sum_{i=1}^{n} \sum_{j=1}^{n} \dfrac{|E_p(\hat{\tau}_{r_i}, {r_i})-E_p(\hat{\tau}_{r_i}, {r_j})|}{E_p(\hat{\tau}_{r_i}, {r_i})}
\end{equation}

The differences are normalized by $E_p(\hat{\tau}_{r_i}, {r_i})$ in order to remove the differences in average efficiencies for each algorithm, so that the algorithms can be compared, purely on flexibility. If $F_r$ of one algorithm is large, then that algorithm cannot generalize well over other environment item ratios, and is thus less flexible.




\subsubsection{Flexibility over environment distribution types}
\label{setup:flexibility:environmentdistributions}

This study evaluates flexibility, by analysing how swarm efficiency on various environment distributions (ED), described in Section~\ref{experimentenvironments}, is affected by swarm specialization ratio, $\tau_i$ (described in Section~\ref{swarmparameters}).

The value for $\tau$, which results in the best average efficiency, $E_P$, for a specific $ED$ is denoted as $\hat{\tau}_{ED}$ and the average efficiency for a specific swarm specialization ratio, $\tau$ with specific ED is denoted $E_P(\tau, ED)$.

Flexibility over a specific environment distribution $ED_i$ is defined as:

\begin{equation}
F_{ED_i} = \sum_{j=1}^{n} \dfrac{|E_(\hat{\tau}_{ED_i}, ED_i)-E_p(\hat{\tau}_{ED_i}, ED_j)|}{E_p(\hat{\tau}_{ED_i}, ED_i)}
\end{equation}

Flexibility over all environment distributions $ED$ is defined as:
\begin{equation}
	F_{ED} = \sum_{i=1}^{n} F_{ED_i}
\end{equation}

A larger value for $F_{ED}$ of one algorithm, compared to another algorithm, means that the algorithm cannot generalize as well over other environment item distributions. It follows that an algorithm with a larger value for $F_{ED}$ is less flexible.

\subsection{Scalability}
\label{setup:scalability}

Scalability is described in Section~\ref{sr:scalabilty}. The study of scalability can be separated into two types: (i) Swarm size scalability and (ii) problem size scalability.

\subsubsection{Swarm size Scalability}
\label{swarmsizescalability}
The efficiency of a robot swarm should be relatively undisturbed by changes in group sizes. This property is known as swarm size scalability. When the efficiency of an algorithm improves linearly (or superlinearly) as swarm size increases, an algorithm is considered scalable. However, due to increased inter-robot interference in larger swarm sizes, scalability is often sub-linear \cite{lerman2002mathematical}. Many swarm robotics algorithms focus on the use of division of labour, navigation or communication in order to decrease inter-robot interference \cite{lerman2002mathematical, schneider1998territorial}. The scalability performance measures are based on the scalability performance measures used in \cite{hecker2015beyond}, which have been adapted for the prioritized foraging problem, by only taking into account the prioritized items.

In order to evaluate the swarm size scalability of each of the algorithms presented, efficiency of each algorithm is examined over a variety of swarm sizes, $c_i$, as defined in Section~\ref{swarmparameters}. In order to compare scalability of the algorithms, the efficiency $E_P$ at each swarm size $c$ is normalized by the efficiency of each algorithm, at the smallest swarm size ($c_0=0.1$). Swarm size scalability, $SS$, for a specific algorithm is calculated as follows:

\begin{equation}
	SS(c_i) = \dfrac{E_P(c_i)-E_P(c_0)}{E_P(c_0)}
\end{equation}

\begin{equation}
	SS = \sum_{i=1}^{n} SS(c_i)
\end{equation}

where $E_P(c_i)$ is the average efficiency $E_P$ over all environments with swarm density $c_i$, and $E_P(c_0)$ is the average efficiency $E_P$ over all experiments where swarm density is $c_0$. By plotting $SS(c_i)$ for all values of $i\in(0,N)$, one will be able to determine how linear the scalability of each algorithm is. Normalizing each value for $E_P(c_i)$ by $E_P(c_0)$ for each algorithm, removes the specific overall efficiencies of each algorithm, and allows the algorithms to be compared purely on scalability. The total swarm scalability $SS$, provides a single figure, per algorithm, which one can use to compare overall swarm scalability. The larger $SS$ is, the better the swarm size scalability. 

The swarm size scalability study will specifically look at large environments ($S=500$) to avoid the possibility of an environment running out of items to forage.

\subsubsection{Problem Scalability}
\label{setup:problemscalability}
If the efficiency, $E_P$, of an algorithm decreases linearly (or super-linearly) as problem complexity increases, then an algorithm can be seen as scalable. Similarly to swarm size scalability, described in Section~\ref{swarmsizescalability}, problem scalability is often sub-linear, due to increased environmental interference.

In order to evaluate the problem scalability of each of the algorithms presented, efficiency of each algorithm is examined over a variety of environment item densities, $p$, defined in Section~\ref{experimentenvironments}. In order to compare scalability of the algorithms to each other, the efficiency $E_P$ at each item density $p_i$ is normalized by the efficiency of each algorithm, at the smallest item density ($p_0=0.1$). 

Problem scalability (PS) for an algorithm, for at an item density $p_i$ is defined as follows:

\begin{equation}
	PS(p_i) = \dfrac{E_P(p_i)-E_P(p_0)}{E_P(p_0)}
\end{equation}

\begin{equation}
	PS = \sum_{i=1}^{n} PS(p_i)
\end{equation}

, where $E_P(p_i)$ is the average efficiency $E_P$ over all environments with environment density $p_i$, and $E_P(p_0)$ is the average efficiency $E_P$ over all experiments where environment density is $p_0$. By plotting $PS(c_i)$ for all values of $i\in(0,N)$, one will be able to determine how linear the problem scalability of each algorithm is. Normalizing each value for $E_P(p_i)$ by $E_P(p_0)$, for each algorithm, removes the specific overall efficiencies of each algorithm, and allows the algorithms to be compared purely on scalability.

Similarly to total swarm scalability $SS$, defined in Section~\ref{swarmsizescalability}, the total problem scalability, $PS$, provides a single figure, per algorithm, which one can use to compare overall problem scalability. The larger $PS$ is, the better the problem scalability.

The problem scalability study will specifically look at large environments ($S=500$) to avoid the possibility of an environment running out of items to forage.

\subsection{Behavioural Performance Measures}
\label{behaviouralperformancemeasures}

Despite not being one of the more typical performance measures for swarm robotics, a number of measures are included to enable further understanding of why the scalability, flexibility and efficiency metrics were observed.

\subsubsection{Items foraged over time}
To give incite into the effect of environmental and swarm parameters of overall performance, and characterise the effects of certain behaviours, the following metrics have been recorded:

\begin{itemize}
\item The total prioritized items foraged over time, $E^t_P$. The total prioritized items foraged are recorded every 200 time steps and are normalized with the total prioritized items that exist in the specific environment.
\item The total non-prioritized items foraged over time, $E^t_{NP}$. The total non-prioritized items foraged are recorded every 200 time steps and are normalized with the total non-prioritized items that exist in the specific environment.
\end{itemize}

\subsubsection{Swarm Specialization Ratio over time}
Swarm specialization ratio stays constant for the Desert ant algorithm and the Na\"ive algorithm, but the swarm specialization ratio changes for the Honey bee algorithm, due to the division of labour mechanisms. In order to gain more understanding of how the division of labour mechanism is performing, the swarm specialization ratio over time, $\tau_t$ is tracked. The swarm specialization ratio is recorded every 200 time steps.

\subsubsection{Time Spent Performing Recruitment}
Unlike the Desert ant algorithm and the Na\"ive algorithm, the Honey bee algorithm robots perform behaviours that are not directly involved in retrieving items - in particular, the recruitment activities form part of the division of labour mechanism. In order to better understand the influence of the division of labour mechanisms, the average percentage of each robot in a swarm spent on each division of labour activity is recorded as follows:

\begin{itemize}
\item $t_{wait}$ - the average percentage of total time steps spent by each robot in the waiting state.
\item $t_{recruitment}$ - the average percentage of total time steps spent by each robot in the recruitment state.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary}
\label{third:summary}
The robots used in this study are based on the e-puck robots, but with gripper capabilities. The robots used a navigation and obstacle avoidance technique based on the flocking behaviour of birds where a global attractor force attracts the robot in a specific direction, while the local attractor force guides a robot around localized obstacles. A simple 2-dimensional grid-based simulator is used. Only a single robot or item occupy a single grid cell at any time point.

Different types of environment distributions were generated for experimentation. The environment types defined have the four following distributions: uniform distribution, Gaussian distribution, clustered distribution and vein distribution. The following environmental parameters were varied: item density, environment size and item type ratio. The following swarm parameters chosen for each of the algorithms were presented: initial swarm specialization ratio, swarm density, and honey bee specific parameters.

Performance measures were selected to evaluate the efficiency of the algorithms, as well as the scalability and flexibility of the algorithms. Lastly, a set of behavioural performance measures are presented in order to gain insight into individual behaviours of the algorithms, namely (i) Items foraged over time (ii) Swarm specialization ratio over time and (iii) the time spent performing recruitment activities.

%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%